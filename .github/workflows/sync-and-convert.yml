name: Sync with Upstream and Convert Items

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      force_full_conversion:
        description: 'Force full conversion of all items'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

env:
  UPSTREAM_REPO: 'NotEnoughUpdates/NotEnoughUpdates-REPO'
  CONVERTED_BRANCH: 'converted-items'

jobs:
  sync-and-convert:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Add upstream and sync
      run: |
        git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
        git fetch upstream
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"

        CURRENT_HEAD=$(git rev-parse HEAD)
        UPSTREAM_HEAD=$(git rev-parse upstream/master)

        if [[ "$CURRENT_HEAD" != "$UPSTREAM_HEAD" ]] || [[ "${{ github.event.inputs.force_full_conversion }}" == "true" ]]; then
          echo "Changes detected, syncing and converting..."
          git checkout master
          git merge upstream/master --no-edit -X theirs
          git push origin master

          git fetch origin ${{ env.CONVERTED_BRANCH }} 2>/dev/null || true
          git checkout -B ${{ env.CONVERTED_BRANCH }}
        else
          echo "No changes detected, skipping conversion"
          exit 0
        fi

    - name: Analyze items
      run: |
        cat > analyze_items.py << 'EOF'
        import json, os, re
        from pathlib import Path

        def needs_datafixer(item_data):
            nbttag = item_data.get('nbttag', '')
            if not nbttag or nbttag.strip() in ['{}', '']:
                return False
            complex_patterns = ['SkullOwner:', 'Enchantments:', 'ExtraAttributes:', 'display:']
            return any(pattern in nbttag for pattern in complex_patterns) or len(nbttag) > 1000

        items_dir = Path('items')
        simple_items = []
        datafixer_items = []

        files_to_process = list(items_dir.glob('*.json'))

        for filepath in files_to_process:
            if not filepath.exists():
                continue
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    item_data = json.load(f)
                item_id = item_data.get('internalname', filepath.stem)
                if needs_datafixer(item_data):
                    datafixer_items.append(item_id)
                else:
                    simple_items.append(item_id)
            except:
                datafixer_items.append(filepath.stem)

        with open('simple_items.json', 'w') as f:
            json.dump(simple_items, f)
        with open('datafixer_items.json', 'w') as f:
            json.dump(datafixer_items, f)
        print(f'Analysis: {len(simple_items)} simple, {len(datafixer_items)} need DataFixer')
        EOF

        python3 analyze_items.py

    - name: Convert simple items
      run: |
        cat > convert_simple.py << 'EOF'
        import json
        from pathlib import Path

        with open('simple_items.json') as f:
            simple_items = json.load(f)

        for item_id in simple_items:
            filepath = Path(f'items/{item_id}.json')
            if not filepath.exists():
                continue
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    item_data = json.load(f)
                item_data['format_version'] = 1
                item_data['conversion_method'] = 'simple'
                item_data['converted_simple'] = True
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump(item_data, f, indent=2, ensure_ascii=False)
            except:
                pass
        print(f'Converted {len(simple_items)} simple items')
        EOF

        python3 convert_simple.py

    - name: Create sophisticated DataFixer converter
      run: |
        mkdir -p converter/src/main/java

        cat > converter/build.gradle << 'EOF'
        plugins {
            id 'java'
            id 'application'
        }
        repositories {
            mavenCentral()
        }
        dependencies {
            implementation 'com.google.code.gson:gson:2.10.1'
        }
        application {
            mainClass = 'ModernNBTConverter'
        }
        java {
            toolchain {
                languageVersion = JavaLanguageVersion.of(21)
            }
        }
        EOF

        cat > converter/src/main/java/ModernNBTConverter.java << 'EOF'
        import com.google.gson.*;
        import java.io.*;
        import java.nio.file.*;
        import java.util.*;
        import java.util.regex.Pattern;
        import java.util.regex.Matcher;

        public class ModernNBTConverter {
        	private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

        	public static void main(String[] args) {
        		try {
        			Path datafixerItemsPath = Paths.get("../datafixer_items.json");
        			if (!Files.exists(datafixerItemsPath)) {
        				System.out.println("No datafixer items to convert");
        				return;
        			}

        			String content = Files.readString(datafixerItemsPath);
        			JsonArray itemIds = JsonParser.parseString(content).getAsJsonArray();
        			System.out.println("Converting " + itemIds.size() + " items to 1.21.5 component format...");

        			int converted = 0;
        			int failed = 0;

        			for (JsonElement element : itemIds) {
        				String itemId = element.getAsString();
        				Path itemPath = Paths.get("../items", itemId + ".json");
        				if (!Files.exists(itemPath)) continue;

        				try {
        					String itemContent = Files.readString(itemPath);
        					JsonObject itemData = JsonParser.parseString(itemContent).getAsJsonObject();

        					String oldNbt = itemData.has("nbttag") ? itemData.get("nbttag").getAsString() : "{}";
        					String oldItemId = itemData.has("itemid") ? itemData.get("itemid").getAsString() : "minecraft:stone";
        					int damage = itemData.has("damage") ? itemData.get("damage").getAsInt() : 0;

        					// Parse lore from the JSON for complete conversion
        					List<String> jsonLore = new ArrayList<>();
        					if (itemData.has("lore") && itemData.get("lore").isJsonArray()) {
        						JsonArray loreArray = itemData.getAsJsonArray("lore");
        						for (JsonElement loreElement : loreArray) {
        							jsonLore.add(loreElement.getAsString());
        						}
        					}

        					// Parse display name from JSON for consistency
        					String displayName = itemData.has("displayname") ? itemData.get("displayname").getAsString() : "";

        					// Convert to modern 1.21.5 component format
        					JsonObject modernNbt = convertTo1215ComponentFormat(oldNbt, oldItemId, damage, jsonLore, displayName);

        					// Update the item with modern NBT (compact JSON)
        					itemData.addProperty("nbttag", compactJsonString(modernNbt.toString()));
        					itemData.addProperty("format_version", 1);
        					itemData.addProperty("conversion_method", "modern_1215_components");
        					itemData.addProperty("converted_modern", true);
        					itemData.addProperty("damage", 0);

        					// Update item ID if it changed during conversion
        					if (modernNbt.has("id")) {
        						itemData.addProperty("itemid", modernNbt.get("id").getAsString());
        					}

        					// Convert lore array to modern JSON text components (for consistency)
        					if (itemData.has("lore") && itemData.get("lore").isJsonArray()) {
        						JsonArray modernLoreArray = new JsonArray();
        						for (String loreLine : jsonLore) {
        							modernLoreArray.add(convertMinecraftTextToJsonCompact(loreLine));
        						}
        						itemData.add("lore", modernLoreArray);
        					}

        					// Convert display name to modern JSON text component
        					if (itemData.has("displayname") && !displayName.trim().startsWith("{")) {
        						itemData.addProperty("displayname", convertMinecraftTextToJsonCompact(displayName));
        					}

        					Files.writeString(itemPath, GSON.toJson(itemData));
        					converted++;

        					if (converted % 1000 == 0) {
        						System.out.println("Converted " + converted + " items...");
        					}

        				} catch (Exception e) {
        					System.err.println("Error converting " + itemId + ": " + e.getMessage());
        					failed++;
        				}
        			}

        			System.out.println("Conversion complete: " + converted + " converted, " + failed + " failed");

        		} catch (Exception e) {
        			System.err.println("Converter failed: " + e.getMessage());
        			e.printStackTrace();
        			System.exit(1);
        		}
        	}

        	private static JsonObject convertTo1215ComponentFormat(String oldNbtString, String itemId, int damage, List<String> lore, String displayName) {
        		JsonObject modernItem = new JsonObject();

        		// Convert item ID from old format to new
        		String modernItemId = convertItemId(itemId, damage);
        		modernItem.addProperty("id", modernItemId);
        		modernItem.addProperty("count", 1);

        		// Parse the old NBT structure
        		NBTData oldNbt = parseOldNBT(oldNbtString);

        		// Create modern components object
        		JsonObject components = new JsonObject();

        		// Convert display components with priority given to JSON data
        		convertDisplayComponents(oldNbt, components, lore, displayName);

        		// Convert ExtraAttributes to custom_data
        		convertExtraAttributes(oldNbt, components);

        		// Convert enchantments
        		convertEnchantments(oldNbt, components);

        		// Convert other properties
        		convertOtherProperties(oldNbt, components);

        		// Add components to modern item if any exist
        		if (components.size() > 0) {
        			modernItem.add("components", components);
        		}

        		return modernItem;
        	}

        	private static String convertItemId(String oldId, int damage) {
        		// Handle common 1.8.9 -> modern item ID conversions
        		switch (oldId) {
        			case "minecraft:skull":
        				return damage == 3 ? "minecraft:player_head" : "minecraft:skeleton_skull";
        			case "minecraft:monster_egg":
        				return "minecraft:infested_stone";
        			case "minecraft:spawn_egg":
        				switch (damage) {
        					case 50: return "minecraft:creeper_spawn_egg";
        					case 51: return "minecraft:skeleton_spawn_egg";
        					case 52: return "minecraft:spider_spawn_egg";
        					case 54: return "minecraft:zombie_spawn_egg";
        					case 55: return "minecraft:slime_spawn_egg";
        					case 56: return "minecraft:ghast_spawn_egg";
        					case 57: return "minecraft:zombified_piglin_spawn_egg";
        					case 58: return "minecraft:enderman_spawn_egg";
        					case 59: return "minecraft:cave_spider_spawn_egg";
        					case 60: return "minecraft:silverfish_spawn_egg";
        					case 61: return "minecraft:blaze_spawn_egg";
        					case 62: return "minecraft:magma_cube_spawn_egg";
        					case 65: return "minecraft:bat_spawn_egg";
        					case 66: return "minecraft:witch_spawn_egg";
        					case 67: return "minecraft:endermite_spawn_egg";
        					case 68: return "minecraft:guardian_spawn_egg";
        					case 90: return "minecraft:pig_spawn_egg";
        					case 91: return "minecraft:sheep_spawn_egg";
        					case 92: return "minecraft:cow_spawn_egg";
        					case 93: return "minecraft:chicken_spawn_egg";
        					case 94: return "minecraft:squid_spawn_egg";
        					case 95: return "minecraft:wolf_spawn_egg";
        					case 96: return "minecraft:mooshroom_spawn_egg";
        					case 98: return "minecraft:ocelot_spawn_egg";
        					case 100: return "minecraft:horse_spawn_egg";
        					case 101: return "minecraft:rabbit_spawn_egg";
        					case 120: return "minecraft:villager_spawn_egg";
        					default: return "minecraft:pig_spawn_egg";
        				}
        			case "minecraft:wool":
        				String[] woolColors = {"white", "orange", "magenta", "light_blue", "yellow", "lime", 
        									   "pink", "gray", "light_gray", "cyan", "purple", "blue", 
        									   "brown", "green", "red", "black"};
        				if (damage >= 0 && damage < woolColors.length) {
        					return "minecraft:" + woolColors[damage] + "_wool";
        				}
        				return "minecraft:white_wool";
        			default:
        				return oldId;
        		}
        	}

        	private static void convertDisplayComponents(NBTData oldNbt, JsonObject components, List<String> jsonLore, String jsonDisplayName) {
        		// Convert display name - prioritize JSON data over NBT
        		String nameToUse = !jsonDisplayName.isEmpty() ? jsonDisplayName : oldNbt.displayName;
        		if (nameToUse != null && !nameToUse.isEmpty() && !nameToUse.trim().startsWith("{")) {
        			String jsonName = convertMinecraftTextToJsonCompact(nameToUse);
        			components.addProperty("minecraft:custom_name", jsonName);
        		}

        		// Convert lore - prioritize JSON data over NBT and include ALL lines
        		List<String> loreToUse = !jsonLore.isEmpty() ? jsonLore : oldNbt.lore;
        		if (loreToUse != null && !loreToUse.isEmpty()) {
        			JsonArray loreArray = new JsonArray();
        			for (String loreLine : loreToUse) {
        				if (!loreLine.trim().startsWith("{")) {
        					String convertedLoreLine = convertMinecraftTextToJsonCompact(loreLine);
        					loreArray.add(convertedLoreLine);
        				} else {
        					loreArray.add(compactJsonString(loreLine));
        				}
        			}
        			components.add("minecraft:lore", loreArray);
        		}
        	}

        	private static void convertExtraAttributes(NBTData oldNbt, JsonObject components) {
        		if (oldNbt.extraAttributes != null && !oldNbt.extraAttributes.isEmpty()) {
        			JsonObject customData = new JsonObject();

        			// Convert all ExtraAttributes key-value pairs
        			for (Map.Entry<String, Object> entry : oldNbt.extraAttributes.entrySet()) {
        				String key = entry.getKey();
        				Object value = entry.getValue();

        				if (value instanceof String) {
        					customData.addProperty(key, (String) value);
        				} else if (value instanceof Number) {
        					customData.addProperty(key, (Number) value);
        				} else if (value instanceof Boolean) {
        					customData.addProperty(key, (Boolean) value);
        				} else {
        					customData.addProperty(key, value.toString());
        				}
        			}

        			if (customData.size() > 0) {
        				components.add("minecraft:custom_data", customData);
        			}
        		}
        	}

        	private static void convertEnchantments(NBTData oldNbt, JsonObject components) {
        		if (oldNbt.enchantments != null && !oldNbt.enchantments.isEmpty()) {
        			JsonObject enchantments = new JsonObject();
        			JsonObject levels = new JsonObject();

        			for (Map.Entry<String, Integer> entry : oldNbt.enchantments.entrySet()) {
        				String enchId = entry.getKey();
        				Integer level = entry.getValue();

        				// Convert numeric enchantment IDs to modern names
        				String modernEnchName = convertEnchantmentId(enchId);
        				if (modernEnchName != null) {
        					levels.addProperty(modernEnchName, level);
        				}
        			}

        			if (levels.size() > 0) {
        				enchantments.add("levels", levels);
        				enchantments.addProperty("show_in_tooltip", true);
        				components.add("minecraft:enchantments", enchantments);
        			}
        		}
        	}

        	private static void convertOtherProperties(NBTData oldNbt, JsonObject components) {
        		// Convert HideFlags to hide_additional_tooltip
        		if (oldNbt.hideFlags > 0) {
        			components.add("minecraft:hide_additional_tooltip", new JsonObject());
        		}

        		// Convert CustomModelData
        		if (oldNbt.customModelData > 0) {
        			components.addProperty("minecraft:custom_model_data", oldNbt.customModelData);
        		}

        		// Convert Unbreakable
        		if (oldNbt.unbreakable) {
        			components.add("minecraft:unbreakable", new JsonObject());
        		}

        		// Convert SkullOwner to profile
        		if (oldNbt.skullOwner != null) {
        			JsonObject profile = new JsonObject();

        			if (oldNbt.skullTexture != null) {
        				JsonObject properties = new JsonObject();
        				JsonArray textures = new JsonArray();
        				JsonObject texture = new JsonObject();
        				texture.addProperty("value", oldNbt.skullTexture);
        				textures.add(texture);
        				properties.add("textures", textures);
        				profile.add("properties", properties);
        			}

        			if (oldNbt.skullOwner.length() > 0) {
        				profile.addProperty("name", oldNbt.skullOwner);
        			}

        			components.add("minecraft:profile", profile);
        		}
        	}

        	private static String convertMinecraftTextToJsonCompact(String minecraftText) {
        		if (minecraftText == null || minecraftText.isEmpty()) {
        			return "{\"text\":\"\"}";
        		}

        		// If it's already JSON, return as-is (compacted)
        		if (minecraftText.trim().startsWith("{")) {
        			return compactJsonString(minecraftText);
        		}

        		// Handle multiple color codes in one line by creating an array of text components
        		List<JsonObject> textParts = new ArrayList<>();

        		int lastIndex = 0;
        		String currentColor = null;
        		boolean bold = false, italic = false, underlined = false, strikethrough = false, obfuscated = false;

        		// Find all formatting codes
        		Pattern formattingPattern = Pattern.compile("ยง([0-9a-fk-or])");
        		Matcher matcher = formattingPattern.matcher(minecraftText);

        		while (matcher.find()) {
        			// Add text segment before this formatting code
        			if (matcher.start() > lastIndex) {
        				String textSegment = minecraftText.substring(lastIndex, matcher.start());
        				if (!textSegment.isEmpty()) {
        					JsonObject textComponent = createTextComponent(textSegment, currentColor, bold, italic, underlined, strikethrough, obfuscated);
        					textParts.add(textComponent);
        				}
        			}

        			char code = matcher.group(1).charAt(0);
        			String colorName = getColorName(String.valueOf(code));

        			if (colorName != null) {
        				// Color code - reset formatting but keep the color
        				currentColor = colorName;
        				bold = italic = underlined = strikethrough = obfuscated = false;
        			} else {
        				// Formatting code
        				switch (code) {
        					case 'l': bold = true; break;
        					case 'o': italic = true; break;
        					case 'n': underlined = true; break;
        					case 'm': strikethrough = true; break;
        					case 'k': obfuscated = true; break;
        					case 'r': // Reset all formatting
        						currentColor = null;
        						bold = italic = underlined = strikethrough = obfuscated = false;
        						break;
        				}
        			}

        			lastIndex = matcher.end();
        		}

        		// Add remaining text after last formatting code
        		if (lastIndex < minecraftText.length()) {
        			String textSegment = minecraftText.substring(lastIndex);
        			if (!textSegment.isEmpty()) {
        				JsonObject textComponent = createTextComponent(textSegment, currentColor, bold, italic, underlined, strikethrough, obfuscated);
        				textParts.add(textComponent);
        			}
        		}

        		// Handle case where there are no formatting codes at all
        		if (textParts.isEmpty()) {
        			String cleanText = minecraftText.replaceAll("ยง[0-9a-fk-or]", "");
        			JsonObject textComponent = createTextComponent(cleanText, null, false, false, false, false, false);
        			textParts.add(textComponent);
        		}

        		// If only one part, return it directly
        		if (textParts.size() == 1) {
        			return compactJsonString(textParts.get(0).toString());
        		}

        		// Multiple parts - create a compound text component
        		JsonObject mainComponent = new JsonObject();
        		mainComponent.addProperty("text", "");
        		JsonArray extraArray = new JsonArray();

        		for (JsonObject part : textParts) {
        			extraArray.add(part);
        		}

        		mainComponent.add("extra", extraArray);

        		return compactJsonString(mainComponent.toString());
        	}

        	private static JsonObject createTextComponent(String text, String color, boolean bold, boolean italic, boolean underlined, boolean strikethrough, boolean obfuscated) {
        		JsonObject component = new JsonObject();
        		component.addProperty("text", text);

        		if (color != null) {
        			component.addProperty("color", color);
        		}
        		if (bold) component.addProperty("bold", true);
        		if (italic) component.addProperty("italic", true);
        		if (underlined) component.addProperty("underlined", true);
        		if (strikethrough) component.addProperty("strikethrough", true);
        		if (obfuscated) component.addProperty("obfuscated", true);

        		return component;
        	}

        	private static String compactJsonString(String jsonString) {
        		// Remove unnecessary whitespace and line breaks from JSON
        		return jsonString.replaceAll("\\s*\\n\\s*", "").replaceAll("\\s{2,}", " ").trim();
        	}

        	private static String getColorName(String colorCode) {
        		switch (colorCode) {
        			case "0": return "black";
        			case "1": return "dark_blue";
        			case "2": return "dark_green";
        			case "3": return "dark_aqua";
        			case "4": return "dark_red";
        			case "5": return "dark_purple";
        			case "6": return "gold";
        			case "7": return "gray";
        			case "8": return "dark_gray";
        			case "9": return "blue";
        			case "a": return "green";
        			case "b": return "aqua";
        			case "c": return "red";
        			case "d": return "light_purple";
        			case "e": return "yellow";
        			case "f": return "white";
        			default: return null;
        		}
        	}

        	private static String convertEnchantmentId(String enchId) {
        		// Handle both numeric and string enchantment IDs
        		try {
        			int id = Integer.parseInt(enchId);
        			String[] enchantmentNames = {
        				"minecraft:protection", "minecraft:fire_protection", "minecraft:feather_falling", "minecraft:blast_protection",
        				"minecraft:projectile_protection", "minecraft:respiration", "minecraft:aqua_affinity", "minecraft:thorns",
        				"minecraft:depth_strider", "minecraft:frost_walker", "minecraft:binding_curse", "minecraft:soul_speed",
        				"minecraft:swift_sneak", "minecraft:sharpness", "minecraft:smite", "minecraft:bane_of_arthropods",
        				"minecraft:knockback", "minecraft:fire_aspect", "minecraft:looting", "minecraft:sweeping_edge",
        				"minecraft:efficiency", "minecraft:silk_touch", "minecraft:unbreakable", "minecraft:fortune",
        				"minecraft:power", "minecraft:punch", "minecraft:flame", "minecraft:infinity"
        			};
        			return (id >= 0 && id < enchantmentNames.length) ? enchantmentNames[id] : null;
        		} catch (NumberFormatException e) {
        			// Already a string ID, return as-is if it looks like a modern enchantment
        			return enchId.startsWith("minecraft:") ? enchId : "minecraft:" + enchId.toLowerCase();
        		}
        	}

        	private static NBTData parseOldNBT(String nbtString) {
        		NBTData data = new NBTData();

        		if (nbtString == null || nbtString.trim().isEmpty() || nbtString.equals("{}")) {
        			return data;
        		}

        		try {
        			// Parse display name
        			Pattern namePattern = Pattern.compile("Name:\"([^\"]+)\"");
        			Matcher nameMatcher = namePattern.matcher(nbtString);
        			if (nameMatcher.find()) {
        				data.displayName = nameMatcher.group(1);
        			}

        			// Parse lore
        			Pattern lorePattern = Pattern.compile("Lore:\\[([^\\]]+)\\]");
        			Matcher loreMatcher = lorePattern.matcher(nbtString);
        			if (loreMatcher.find()) {
        				String loreContent = loreMatcher.group(1);
        				data.lore = new ArrayList<>();

        				// Split lore lines and clean them up
        				String[] loreLines = loreContent.split(",");
        				for (String line : loreLines) {
        					line = line.trim();
        					if (line.matches("\\d+:\".*\"")) {
        						// Handle indexed lore format: 0:"text"
        						String loreLine = line.substring(line.indexOf('"') + 1, line.lastIndexOf('"'));
        						data.lore.add(loreLine);
        					} else if (line.startsWith("\"") && line.endsWith("\"")) {
        						// Handle quoted lore: "text"
        						data.lore.add(line.substring(1, line.length() - 1));
        					}
        				}
        			}

        			// Parse ExtraAttributes
        			Pattern extraAttrsPattern = Pattern.compile("ExtraAttributes:\\{([^}]+)\\}");
        			Matcher extraMatcher = extraAttrsPattern.matcher(nbtString);
        			if (extraMatcher.find()) {
        				String extraContent = extraMatcher.group(1);
        				data.extraAttributes = new HashMap<>();

        				// Parse key-value pairs in ExtraAttributes
        				String[] pairs = extraContent.split(",");
        				for (String pair : pairs) {
        					String[] keyValue = pair.split(":", 2);
        					if (keyValue.length == 2) {
        						String key = keyValue[0].trim();
        						String value = keyValue[1].trim();

        						// Remove quotes from key
        						if (key.startsWith("\"") && key.endsWith("\"")) {
        							key = key.substring(1, key.length() - 1);
        						}

        						// Parse value based on type
        						if (value.startsWith("\"") && value.endsWith("\"")) {
        							// String value
        							data.extraAttributes.put(key, value.substring(1, value.length() - 1));
        						} else if (value.endsWith("B") || value.endsWith("b")) {
        							// Boolean value
        							data.extraAttributes.put(key, value.startsWith("1"));
        						} else if (value.contains(".")) {
        							// Float/Double value
        							try {
        								data.extraAttributes.put(key, Double.parseDouble(value.replaceAll("[fFdD]", "")));
        						} catch (NumberFormatException e) {
        								data.extraAttributes.put(key, value);
        							}
        						} else {
        							// Integer value
        							try {
        								data.extraAttributes.put(key, Integer.parseInt(value.replaceAll("[lLsS]", "")));
        							} catch (NumberFormatException e) {
        								data.extraAttributes.put(key, value);
        							}
        						}
        					}
        				}
        			}

        			// Parse HideFlags
        			Pattern hideFlagsPattern = Pattern.compile("HideFlags:(\\d+)");
        			Matcher hideFlags = hideFlagsPattern.matcher(nbtString);
        			if (hideFlags.find()) {
        				data.hideFlags = Integer.parseInt(hideFlags.group(1));
        			}

        			// Parse CustomModelData
        			Pattern customModelPattern = Pattern.compile("CustomModelData:(\\d+)");
        			Matcher customModel = customModelPattern.matcher(nbtString);
        			if (customModel.find()) {
        				data.customModelData = Integer.parseInt(customModel.group(1));
        			}

        			// Parse Unbreakable
        			data.unbreakable = nbtString.contains("Unbreakable:1");

        			// Parse SkullOwner
        			Pattern skullPattern = Pattern.compile("SkullOwner:\\{([^}]+)\\}");
        			Matcher skullMatcher = skullPattern.matcher(nbtString);
        			if (skullMatcher.find()) {
        				String skullContent = skullMatcher.group(1);

        				Pattern namePattern2 = Pattern.compile("Name:\"([^\"]+)\"");
        				Matcher nameMatcher2 = namePattern2.matcher(skullContent);
        				if (nameMatcher2.find()) {
        					data.skullOwner = nameMatcher2.group(1);
        				}

        				Pattern texturePattern = Pattern.compile("Value:\"([^\"]+)\"");
        				Matcher textureMatcher = texturePattern.matcher(skullContent);
        				if (textureMatcher.find()) {
        					data.skullTexture = textureMatcher.group(1);
        				}
        			}

        			// Parse enchantments
        			Pattern enchPattern = Pattern.compile("ench:\\[([^\\]]+)\\]");
        			Matcher enchMatcher = enchPattern.matcher(nbtString);
        			if (enchMatcher.find()) {
        				String enchContent = enchMatcher.group(1);
        				data.enchantments = new HashMap<>();

        				Pattern enchEntryPattern = Pattern.compile("\\{id:(\\d+)[sS]?,lvl:(\\d+)[sS]?\\}");
        				Matcher entryMatcher = enchEntryPattern.matcher(enchContent);

        				while (entryMatcher.find()) {
        					String enchId = entryMatcher.group(1);
        					Integer level = Integer.parseInt(entryMatcher.group(2));
        					data.enchantments.put(enchId, level);
        				}
        			}

        		} catch (Exception e) {
        			System.err.println("Warning: Failed to fully parse NBT: " + e.getMessage());
        		}

        		return data;
        	}

        	// Helper class to store parsed NBT data
        	private static class NBTData {
        		String displayName;
        		List<String> lore;
        		Map<String, Object> extraAttributes;
        		Map<String, Integer> enchantments;
        		int hideFlags = 0;
        		int customModelData = 0;
        		boolean unbreakable = false;
        		String skullOwner;
        		String skullTexture;
        	}
        }
        EOF

    - name: Run sophisticated DataFixer conversion (DEBUG)
      run: |
        echo "=== Pre-conversion checks ==="
        pwd
        ls -la
        echo "=== Checking for input files ==="
        ls -la ../datafixer_items.json || echo "datafixer_items.json not found"
        ls -la ../simple_items.json || echo "simple_items.json not found"
        echo "=== Checking items directory ==="
        ls -la ../items/ | head -5
        echo "=== Input file contents ==="
        if [ -f ../datafixer_items.json ]; then
          echo "DataFixer items count: $(jq length ../datafixer_items.json)"
          echo "First 3 items: $(jq '.[0:3]' ../datafixer_items.json)"
        fi
        if [ -f ../simple_items.json ]; then
          echo "Simple items count: $(jq length ../simple_items.json)"
        fi
        echo "=== Starting conversion ==="
        cd converter
        echo "Current directory: $(pwd)"
        echo "Gradle files present:"
        ls -la build.gradle || echo "No build.gradle"
        echo "Java source files:"
        find src -name "*.java" -exec ls -la {} \; || echo "No Java files found"
        echo "=== Running Gradle with debug output ==="
        gradle run --no-daemon --info --stacktrace
        echo "=== Post-conversion checks ==="
        cd ..
        echo "=== Sample converted item check ==="
        if [ -f ../datafixer_items.json ]; then
          FIRST_ITEM=$(jq -r '.[0]' ../datafixer_items.json)
          if [ -f "../items/${FIRST_ITEM}.json" ]; then
            echo "Checking conversion of: ${FIRST_ITEM}"
            echo "Has format_version: $(jq 'has("format_version")' "../items/${FIRST_ITEM}.json")"
            echo "Has conversion_method: $(jq 'has("conversion_method")' "../items/${FIRST_ITEM}.json")"
            echo "Has converted_modern: $(jq 'has("converted_modern")' "../items/${FIRST_ITEM}.json")"
            echo "NBT preview (first 200 chars): $(jq -r '.nbttag' "../items/${FIRST_ITEM}.json" | head -c 200)..."
          fi
        fi
        echo "=== Git status after conversion ==="
        git status --porcelain | head -10
        echo "=== Checking file modifications ==="
        git diff --name-only | head -10
        echo "=== Debug complete ==="

    - name: Commit and push converted items
      run: |
        git add items/ simple_items.json datafixer_items.json
        if ! git diff --staged --quiet; then
          git commit -m "Convert items to 1.21.5 component format - $(date)"
          git push origin ${{ env.CONVERTED_BRANCH }} --force
          echo "Converted items pushed to ${{ env.CONVERTED_BRANCH }} branch"
        else
          echo "No changes to commit"
        fi
